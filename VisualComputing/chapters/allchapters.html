<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"
        "http://www.w3.org/TR/REC-html40/strict.dtd">

<HTML>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<TITLE>All chapters source codes | Visual Computing: Geometry, Graphics, and Vision</TITLE>
</head>
<body>

<H1>Source codes for all chapters of "Visual Computing: Geometry, Graphics, and Vision"</H1>

<HR>

<H1>Chapter 2: Abstract Data Structures.</H1>


<UL>

<LI> <A HREF="../programs/fibonacci.cpp">Fibonacci.cpp</A>: Compute the first elements of Fibonacci series with or without pointer arithmetic.

<P>

<LI>  <A HREF="../programs/indexremapping.cpp">indexremapping.cpp</A>: Conversions between 1D and 2D array indices of arrays.

<P>

<LI> <A HREF="../programs/multidim-indexremapping.cpp">multidim-indexremapping.cpp</A>: Conversions between 1D and dD array indices of arrays.

<P>

<LI> <A HREF="../programs/linkedlist.cpp">linkedlist.cpp</A>: Simple templated linked list class.

<P>

<LI> <A HREF="../programs/areafloodfill.cpp">areafloodfill.cpp</A>: Area flood-filling using a queue.
Input image <A HREF="../programs/fillex.ppm">fillex.ppm</A>  (Result is written in <A HREF="../programs/floodfill-result.ppm">floodfill-result.ppm</A>)


<P>

<LI> <A HREF="../programs/genericdictionary.cpp">genericdictionary.cpp</A>:
This short program shows how to overload the less than comparison operator to get a generic dictionary. 
Two segments defining the diagonals of a square are created. We associate to them two line equations.
Depending on the position of the sweep line, we show that seg1 is below or above seg2.



<P>

<LI> <A HREF="../programs/ShamosHoey.cpp">ShamosHoey.cpp</A>:
Detect whether a set of line segments intersect or not.
Implement in a STL fashion a simple but optimal algorithm 
 to detect whether there exists an intersection point among a set of n segments in O(n log n) time.
<A HREF="../programs/linesegmentdetect-1.png">Snapshot 1 PNG</A>,
<A HREF="../programs/linesegmentdetect-2.png">Snapshot 2 PNG</A> and
<A HREF="../programs/linesegmentdetect-3.png">Snapshot 3 PNG</A>.

<P>


<LI> <A HREF="../programs/srg.cpp">srg.cpp</A>: Statistical region growing segmentation using the union-find data structure of Tarjan.
Call srg.exe srg-source.ppm.
Input image <A HREF="../programs/srg-source.ppm">srg-source.ppm</A>  (Result is written in <A HREF="../programs/srg-output.ppm">srg-output.ppm</A>)

<P>

<LI> <A HREF="../programs/priorityqueue-stl.cpp">priorityqueue-stl.cpp</A>: Priority queue in C++ STL  (sample program)

<P>

<LI> <A HREF="../programs/hashing-stl.cpp">hashing-stl.cpp</A>: 1D Hashing in C++ STL  (sample program)

<P>

<LI> <A HREF="../programs/traits-numerics.cpp">traits-numerics.cpp</A>: Traits class concept using the numerics class in C++

<P>

<LI> <A HREF="../programs/traits-geometrykernel.cpp">traits-geometrykernel.cpp</A>:  Geometric traits class are useful for encapsulating the geometric kernel and the predicates of algorithms.
The code computes the convex hull of a point set using Andrew's algorithm (traits adapted from the class notes of Lutz Kettner). (This code is not robust. See chapter Robustness for more.) 
Require OpenGL, see <A HREF="../programs/geotraits-convexhull.png">snapshot (PNG)</A>.

</UL>




<H1>Chapter 3: Coordinate Pipelines.</H1>


<UL>

<LI> <A HREF="../programs/casting.cpp">casting.cpp</A>: Sample program which shows how to cast Euclidean into projective points and vice-versa.

<P>


<LI> <A HREF="../programs/segmentintersection-projective.cpp">segmentintersection-projective.cpp</A>: Compute the potential intersection point of two line segments using the cross-product: cross-product for 
 defining supporting lines and cross-product of the line vectors for determining the intersection projective point 
(require OpenGL(R)). 
<A HREF="../programs/segdonotintersect.png">snapshot1 PNG</A> 
<A HREF="../programs/segdointersect.png">snapshot2 PNG</A>
 
<P>

<LI> <A HREF="../programs/PolygonTransform.cpp">PolygonTransform.cpp</A>: 2D polygon transformations (rotations, symmetries, shears, etc.). Require OpenGL(R).
<A HREF="../programs/polygontransform-1.png">snapshot1 PNG</A> 
<A HREF="../programs/polygontransform-2.png">snapshot2 PNG</A>
<A HREF="../programs/polygontransform-3.png">snapshot3 PNG</A> 

<P>

<LI> <A HREF="../programs/3dtransformations.cpp">3dtransformations.cpp</A>: 3D mesh transformations (rotations, symmetries, shears, etc.). Require OpenGL(R).
Require the Stanford bunny mesh in the include file <A HREF="../programs/bunny.h">bunny.h</A>.
<A HREF="../programs/meshtransform-1.png">snapshot1 PNG</A> 
<A HREF="../programs/meshtransform-2.png">snapshot2 PNG</A>
<A HREF="../programs/meshtransform-3.png">snapshot3 PNG</A> 
<BR>
The 3D bunny model is courtesy of (c) <A HREF="http://graphics.stanford.edu/data/3Dscanrep/">The Stanford 3D scanning repository</A>, Marc Levoy.

<P>

<LI> <A HREF="../programs/rotation-by-quaternion.cpp">rotation-by-quaternion.cpp</A>: Sample program that shows how to use quaternion arithmetic for performing rotations
around some given axis. Require OpenGL(R)
<A HREF="../programs/quatforrot-1.png">snapshot1 PNG</A> 
<A HREF="../programs/quatforrot-2.png">snapshot2 PNG</A>

<P>

<LI> <A HREF="../programs/isometricprojection.cpp">isometricprojection.cpp</A>: Choosing the view direction and hence the projection plane for getting an isometric projection of cube(s). Require OpenGL(R)
<A HREF="../programs/isometricprojection.png">snapshot PNG</A> 

<P>

<LI><A HREF="../programs/openglviewport.cpp">openglviewport.cpp</A>: Render several views onto a same device display using viewport mappings. Require OpenGL(R)
<A HREF="../programs/openglviewport.png">snapshot PNG</A> 


<P>

<LI><A HREF="../programs/Unperspective.cpp">Unperspective.cpp</A>: 
Rectify an input perspective image so that the planar surface (eg., sign, etc.) looks as if taken from front position.
You need the input image <A HREF="../programs/newcourt.ppm">newcourt.ppm</A>.
Result image is called  <A HREF="../programs/unperspective-newcourt.ppm">unperspective-newcourt.ppm</A> 


<P>

<LI><A HREF="../programs/BlendHomography.cpp">BlendHomography.cpp</A>: 
Match two perspective images by an homography related a common planar surface (book cover).
You need the input image <A HREF="../programs/bookcovers1.ppm">bookcovers1.ppm</A> and <A HREF="../programs/bookcovers2.ppm">bookcovers2.ppm</A>.
Result image is called  <A HREF="../programs/blendhomography.ppm">blendhomography.ppm</A> 


<P>

<LI><A HREF="../programs/logpolartransform.cpp">logpolartransform.cpp</A>: 
Log-polar transform on a source image.
You need the input image <A HREF="../programs/cambridge512.ppm">cambridge512.ppm</A>.
Result image is called  <A HREF="../programs/logpolar.ppm">logpolar.ppm</A> 


<P>

<LI><A HREF="../programs/sphericalmapping.cpp">sphericalmapping.cpp</A>: 
Spherical mapping (theta-phi) of an image (with given field of view).
You need the input image <A HREF="../programs/normal120deg.ppm">normal120deg.ppm</A>.
Result image is called  <A HREF="../programs/sphericalimage.ppm">sphericalimage.ppm</A> 

<P>

<LI><A HREF="../programs/lineconics.cpp">lineconics.cpp</A>: 
An easy way to rasterize conics, line conics and dual conics.
Result image is called  <A HREF="../programs/draw.ppm">draw.ppm</A> 

<P>

<LI><A HREF="../programs/plucker.cpp">plucker.cpp</A>: 
A sample program using Plucker coordinates of lines to answer incidence or intersection test of lines.
Define the dot product of Plucker lines.

<P>

<LI><A HREF="../programs/radialdistortion.cpp">radialdistortion.cpp</A>: 
A simple interactive interface for visualizing the radial distortion. Require OpenGL(R).
<A HREF="../programs/radialdistortion.png">snapshot PNG</A> 


<P>

<LI><A HREF="../programs/checkerboard.cpp">checkerboard.cpp</A>: 
Create a checkerboard image, save this image into <A HREF="../programs/checkerboard.ppm">checkerboard.ppm</A> and display a textured quad. Require OpenGL(R).
<A HREF="../programs/checkerboarddemo.png">snapshot PNG</A> 



<P>

<LI><A HREF="../programs/spheremap.cpp">spheremap.cpp</A>: 
Reflection mapping using a sphere map environment image and the Utah teapot. Require OpenGL(R).
You need this sphere map image: <A HREF="../programs/mirrorball512.ppm">mirrorball512.ppm</A>.
<A HREF="../programs/spheremap.png">snapshot PNG</A> 


<P>

<LI><A HREF="../programs/latlong2spherical.cpp">latlong2spherical.cpp</A>: 
Environment map conversion procedure using generic pixel-to-ray and ray-to-pixel primitives.
You need this equirectangular environment map image: <A HREF="../programs/latlong.ppm">latlong.ppm</A>.
The output is a spherical mirror ball image <A HREF="../programs/spherical.ppm">spherical.ppm</A> that you can also use in the former
OpenGL(R) reflection mapping program.


</UL>

<H1>Chapter 4: Images.</H1>


<UL>

<LI> <A HREF="../programs/warping.cpp">warping.cpp</A>: Forward and backward image warping.
You need the source image <A HREF="../programs/imagewarping.ppm">imagewarping.ppm</A>. 
The results are: <A HREF="../programs/forwardwarping.ppm">forwardwarping.ppm</A> and <A HREF="../programs/backwardwarping.ppm">backwardwarping.ppm</A>.

<P>

<LI> <A HREF="../programs/composite.cpp">composite.cpp</A>: Image compositing using alpha channel.
You need the source image <A HREF="../programs/furrydog.ppm">furrydog.ppm</A>, the alpha matte <A HREF="../programs/furrydog-matte.ppm">furrydog-matte.ppm</A>
and the background image  <A HREF="../programs/background.ppm">background.ppm</A>
The result is <A HREF="../programs/composite.ppm">composite.ppm</A>.

<P>

<LI> <A HREF="../programs/zoneplate.cpp">zoneplate.cpp</A>: Create a zone plate image to study resampling aliasing artefacts.
The zone plate image  is <A HREF="../programs/zoneplate.ppm">zoneplate.ppm</A>.

<P>

<LI> <A HREF="../programs/zoneplate2.cpp">zoneplate2.cpp</A>: Create another zone plate image to study resampling aliasing artefacts.
The zone plate image  is <A HREF="../programs/zoneplate2.ppm">zoneplate2.ppm</A>.

<P>

<LI> <A HREF="../programs/discreteconvolution.cpp">discreteconvolution.cpp</A>: A light implementation of a discrete convolution procedure using either the Laplacian or Identity kernel.
You need the source image <A HREF="../programs/convolution-input.ppm">convolution-input.ppm</A>.
The result is <A HREF="../programs/convolution-result.ppm">convolution-result.ppm</A>.

<P>

<LI> <A HREF="../programs/colorcube.cpp">colorcube.cpp</A>: Display the RGB color cube in OpenGL(R). 
Here are two snapshots: 
<A HREF="../programs/colorcube-1.png">snapshot1 PNG</A> and
<A HREF="../programs/colorcube-2.png">snapshot2 PNG</A>.


<P>

<LI> <A HREF="../programs/errordiffusion.cpp">errordiffusion.cpp</A>: Various halftoning and dithering techniques. 
You need the source image "lena" <A HREF="../programs/lena.ppm">lena.ppm</A>.<BR>
Here are the results: <A HREF="../programs/binary-threshold.ppm">binary-threshold.ppm</A>,
<A HREF="../programs/binary-randomthreshold.ppm">binary-randomthreshold.ppm</A>
<A HREF="../programs/binary-diffusion.ppm">binary-diffusion.ppm</A>, and
<A HREF="../programs/tone-dither.ppm">tone-dither.ppm</A>.


</UL>



<H1>Chapter 5: Meshes.</H1>


<UL>

<LI> <A HREF="../programs/osculatingcircle.cpp">osculatingcircle.cpp</A>: An interactive demo of osculating circles used to define a parametric curve curvature. Require OpenGL(R)
<A HREF="../programs/osculatingcircle.png">snapshot PNG</A>.
<P>


<LI> <A HREF="../programs/spheresubdivision.cpp">spheresubdivision.cpp</A>: Approximating the sphere by a subdivision mesh. Start from the icosahedron base mesh and iteratively refine the subdivision.
Require OpenGL(R).
<A HREF="../programs/subdivision-2.png">snapshot level 2 PNG</A>,
<A HREF="../programs/subdivision-4.png">snapshot level 4PNG</A>.

<P>

<LI> <A HREF="../programs/bunny-quadremeshing.off">bunny-quadremeshing.off</A>: Quad-dominant remeshing of the Stanford bunny in OFF file format (courtesy of Marinov).
The original bunny model is available from Stanford university. Here is the <A HREF="../programs/bunny.off">bunny.off</A> file.

<P>

<LI> <A HREF="../programs/bunny-proxyremeshing.off">bunny-proxyremeshing.off</A>: Anisotropic remeshing of the Stanford bunny in OFF file format (courtesy of Alliez).

<P>

<LI> <A HREF="../programs/bunny-conformal.obj">bunny-conformal.obj</A>: Conformal parameterization of the Stanford bunny in OBJ file format (courtesy of Degener).

<P>

<LI> <A HREF="../programs/bunny-authalic.obj">bunny-authalic.obj</A>: Authalic/Conformal (obtained by a minimizing some tradeoff criterion) parameterization of the Stanford bunny in OBJ file format (courtesy of Alliez).


<P>


</UL>

The <A HREF="http://web.axelero.hu/karpo/">3D object converter</A> shareware can display and convert numerous mesh formats.<BR>

The bunny 3D model is courtesy of (c) <A HREF="http://graphics.stanford.edu/data/3Dscanrep/">The Stanford 3D scanning repository</A>, Marc Levoy. 



<H1>Chapter 6: Animation.</H1>


<UL>


<LI>  <A HREF="../programs/slerp.cpp">slerp.cpp</A>: Interactive demo in OpenGL(R) of the spherical linear interpolation (SLERP) scheme.
<A HREF="../programs/slerpdemo.png">snapshot PNG</A>.


</UL>



<H1>Chapter 7: Randomization.</H1>


<UL>

<LI> <A HREF="../programs/quicksort.cpp">quicksort.cpp</A>: Implementation of the randomized Quicksort comparison-based sorting algorithm.
<P>

<LI>  <A HREF="../programs/OrderStatistics.cpp">OrderStatistics.cpp</A>: Implementation of the randomized SelectElement comparison-based order statistics algorithm.
Select the k-th smallest element of an array.

<P>

<LI>  <A HREF="../programs/matchsegments.cpp">matchsegments.cpp</A>: Compute the scaled rigid transformation that matches a given pair of segments.

<P>

<LI>  <A HREF="../programs/ransac.cpp">ransac.cpp</A>: Implementation of RANSAC from a pure combinatorial point of view.


<P>

<LI>  <A HREF="../programs/MiniBall.cpp">MiniBall.cpp</A>: Implementation of the randomized recursive incremental construction of the smallest
enclosing ball of a 2D point set (as known as Welzl MINIBALL algorithm).





</UL>



<H1>Chapter 8: Higher Dimensions for 3D.</H1>


<UL>

<LI> <A HREF="../programs/textureperpixel.cpp">textureperpixel.cpp</A>: Implementation of Wei and Levoy texture synthesis algorithm using the
 <A HREF="http://www.cs.umd.edu/~mount/ANN/">approximate nearest library</A>.
You need this input texture <A HREF="../programs/texturesynthesis-input.ppm">texturesynthesis-input.ppm</A>.
The result 2x2 larger texture is written in the image <A HREF="../programs/texturesynthesis-output.ppm">texturesynthesis-output.ppm</A>.

<P>


<LI> <A HREF="../programs/kmeans.cpp">kmeans.cpp</A>:  Implementation of the k-means iterative clusteriing method of Lloyd (vector quantization).
A graphical interface is provided in OpenGL(R). Press any key to perform an iteration.
<A HREF="../programs/kmeansdemo-1.png">Snapshot1 PNG</A>,
<A HREF="../programs/kmeansdemo-2.png">Snapshot2 PNG</A>.

<P>

<LI> <A HREF="../programs/discretevoronoi.cpp">discretevoronoi.cpp</A>:  Rasterize a Voronoi diagram of a set of randomly drawn generators.
<A HREF="../programs/discretevoronoi.png">output example PNG</A>.

<P>

<LI> <A HREF="../programs/SmallEnclosingBall.cpp">SmallEnclosingBall.cpp</A>: 
Compute an approximation of the smallest enclosing ball in large dimensions using the simple iterative method of Badoiu and Clarkson (core-sets).




<P>

<LI> <A HREF="../programs/Orient2D.cpp">Orient2D.cpp</A>:  Graphical interactive illustration of the geometric predicate Orient2D. Require OpengL(R).
<A HREF="../programs/orient2d-1.png">snapshot 1 PNG</A>,
<A HREF="../programs/orient2d-2.png">snapshot 2 PNG</A>,
<A HREF="../programs/orient2d-3.png">snapshot 3 PNG</A>.

</UL>



<H1>Chapter 9: Robustness.</H1>


<UL>

<LI> <A HREF="../programs/heron.cpp">heron.cpp</A>: Floating-point computation of triangle areas using Heron's formula. Emphasize on the numerical errors (float or double data type) and their
impact in the flow of algorithm.

<P>

<LI> <A HREF="../programs/segmentintersection-primitive.cpp">segmentintersection-primitive.cpp</A>: Define the predicate that answers true if and only if two line segments intersect.
The predicate uses only Orient2D orientation tests.
<A HREF="../programs/robustsegment-1.png">Snapshot 1 PNG</A>,
<A HREF="../programs/robustsegment-2.png">Snapshot 1 PNG</A>.

</UL>




<br>&nbsp
<br>Last updated, May 2005.

</body>
</html>